#!/bin/bash
#===============================================================================
# FILE:         functions.sh
#
# USAGE:        Include in other scripts, e.g. source functions.sh
#
# DESCRIPTION:  Defines but does not execute functions that can be used
#               in other scripts
# REQUIRED
# VARIABLES:    LOG_FILE - path to a file used for logging
#===============================================================================

# Treat unset variables as an error when peforming parameter expansion
# Exit immediately on errors
set -o nounset -o errexit

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

# @brief Writes a message to a screen and to a log file, with the "log:" prefix
# @param message to be logged
# @return status of file logging command
# @example log "Hello world"
log()
{
    # Use message with prefix to distinguish logs generated by setup scripts
    local msg="log: $@"

    # Write message to screen and log file
    (echo "$msg" 2>&1) | tee -a $LOG_FILE
    return ${PIPESTATUS[1]}
}

# @brief Logs a command with "cmd:" prefix and executes it
# @param command to be executed
# @return status of executed command
# @example cmd "echo 'I was printed with cmd function'"
cmd()
{
    # Record command to be executed to the log file
    echo "cmd: $@" >> $LOG_FILE

    # Execute command
    # Redirect stdout and stderr to screen and log file
    (eval "$@" 2>&1) | tee -a $LOG_FILE
    return ${PIPESTATUS[0]}
}

# @brief Prints summary and aborts the script in case of non-zero error code
# @param error code to be compared against 0
# @param function name to be reported in case of failure
# @param message to be reported in case of failure
# @return none in case of success; script abort in case of failure
# @example err "$?" "$FUNCNAME" "message to be shown and logged"
err()
{
    local error="$1"
    local funcname="$2"
    local msg="$3"

    if [[ "$error" -ne 0 ]]; then
        log "$funcname: $msg: $error"
        log "Aborting!"
        exit 1
    fi
}
# @brief Checks whether partitions count for given hdd is as expected
# @param path to hdd, without partition number
# @param expected partitions count
# @return 0 when hdd has expected number of partions; 1 otherwise
# @example checkPartitionsCount /dev/sda 3
checkPartitionsCount()
{
    local hdd=$1
    local cnt=$2

    local lines=$(lsblk $hdd | wc -l)
    local ptns=$(($lines - 2))
    local ret=0

    if [[ "$cnt" -ne "$ptns" ]]; then
        log "Wrong partition count on $hdd. Expected:$cnt; found:$ptns"
        ret=1
    fi

    return $ret
}

# @brief Creates a partition on a hdd
# @param path to hdd, without partition number, e.g. /dev/sda
# @param partition type - "p" for primary, "e" for extended
# @param partition number, e.g. "1" for "/dev/sda1"
# @param partition size, e.g. "+1G" for 1 GiB, "" for remaining space
# @param partition code, e.g. "82" for swap, "83" for Linux partition, etc
# @return none for success; script abort for failure
# @example createPartition /dev/sda p 2 "+128M" 83
createPartition()
{
    local hdd="$1"
    local partType="$2"
    local partNb="$3"
    local partSize="$4"
    local partCode="$5"

    local partCodeNb="" # No partition nb for code setting for 1st partition
    
    # For parititons >1 it is necessary to provide partition number
    if [[ $partNb -ne 1 ]]; then
        partCodeNb=$partNb
    fi

    cat <<-EOF | fdisk $hdd
	n
	$partType
	$partNb
	
	$partSize
	t
	$partCodeNb
	$partCode
	w
	EOF

    # TODO Try to find more elegant solution
    # sync and partprobe did not work to avoid following report:
    # "Re-reading the partition table failed: Device or resource busy"
    sleep 10

    err "$?" "$FUNCNAME" "failed to create partition"
}

# @brief Sets bootable flag of the partition to true
# @param path to hdd, without partition number, e.g. /dev/sda
# @param partition number, .e.g. "1" for "/dev/sda1"
# @return none for success; script abort for failure
# @example setPartitionBootable /dev/sda 2
# @note Best executed when all (at least two) partitions are created
setPartitionBootable()
{
    local hdd="$1"     # e.g. /dev/sda
    local partNb="$2"   # e.g. "1" for "/dev/sda1"

    cat <<-EOF | fdisk $hdd
	a
	$partNb
	w
	EOF

    err "$?" "$FUNCNAME" "failed to set partition $hdd/$partNb as bootable"
}

